// Generated by tools/gen_orca_rulesets.py from /Users/laurenceputterman/assorted_projects/Orca/Orca-NewOrca/../shared/orca_rulesets.json.
// DO NOT EDIT MANUALLY.

export type DigitalSourceV1 = { type: number; index: number; threshold?: number; hysteresis?: number };
export type DpadLayerV1 = {
  mode_up: number;
  mode_down: number;
  mode_left: number;
  mode_right: number;
  enable: DigitalSourceV1;
  up: DigitalSourceV1;
  down: DigitalSourceV1;
  left: DigitalSourceV1;
  right: DigitalSourceV1;
};

export type OrcaRulesetContext = {
  digitalMappings: number[];
  dpadLayer: DpadLayerV1;
};

const DIGITAL_SRC_NONE = 0;
const DIGITAL_SRC_ORCA_DIGITAL_BIT = 1;
const DPAD_LAYER_DISABLED = 0;
const ORCA_DUMMY_FIELD = 16;

function dpadSourcesDigital(layer: DpadLayerV1, includeEnable: boolean): boolean {
  if (!layer) return false;
  const isDigital = (src: DigitalSourceV1): boolean => src.type === DIGITAL_SRC_NONE || src.type === DIGITAL_SRC_ORCA_DIGITAL_BIT;
  if (includeEnable && !isDigital(layer.enable)) return false;
  if (!isDigital(layer.up)) return false;
  if (!isDigital(layer.down)) return false;
  if (!isDigital(layer.left)) return false;
  if (!isDigital(layer.right)) return false;
  return true;
}

function sourceOverlapsOutputs(mapping: number[], source: number, outputDests: readonly number[]): boolean {
  if (source === ORCA_DUMMY_FIELD) return false;
  return outputDests.some((dest) => mapping[dest] === source);
}

function dpadDirectionOverlaps(mapping: number[], src: DigitalSourceV1, mode: number, outputDests: readonly number[]): boolean {
  if (!src) return false;
  if (mode === DPAD_LAYER_DISABLED) return false;
  if (src.type !== DIGITAL_SRC_ORCA_DIGITAL_BIT) return false;
  return sourceOverlapsOutputs(mapping, src.index, outputDests);
}

function dpadNoOutputOverlap(mapping: number[], layer: DpadLayerV1, outputDests: readonly number[]): boolean {
  if (!mapping || !layer) return false;
  if (dpadDirectionOverlaps(mapping, layer.up, layer.mode_up, outputDests)) return false;
  if (dpadDirectionOverlaps(mapping, layer.down, layer.mode_down, outputDests)) return false;
  if (dpadDirectionOverlaps(mapping, layer.left, layer.mode_left, outputDests)) return false;
  if (dpadDirectionOverlaps(mapping, layer.right, layer.mode_right, outputDests)) return false;
  return true;
}

export const MELEE_RULESET_VERIFICATION_ID = 'melee_ruleset_verification';
export const MELEE_RULESET_VERIFICATION_ACTIVATION_INPUTS = [15, 13, 14] as const;
export const MELEE_RULESET_VERIFICATION_OUTPUT_BUTTONS = [5, 8, 0, 11] as const;
const MELEE_RULESET_VERIFICATION_OUTPUT_DESTINATIONS = [0, 1, 2, 3, 4, 5, 6, 15] as const;

export function isMeleeRulesetVerificationValid(ctx: OrcaRulesetContext): boolean {
  if (!ctx || !ctx.digitalMappings || !ctx.dpadLayer) return false;
  return (((ctx.digitalMappings[0] === 0 && ctx.digitalMappings[7] === 7 && ctx.digitalMappings[8] === 8 && ctx.digitalMappings[9] === 9 && ctx.digitalMappings[10] === 10) || (ctx.digitalMappings[0] === 10 && ctx.digitalMappings[10] === 0 && ctx.digitalMappings[7] === 7 && ctx.digitalMappings[8] === 8 && ctx.digitalMappings[9] === 9)) && dpadSourcesDigital(ctx.dpadLayer, true) && dpadNoOutputOverlap(ctx.digitalMappings, ctx.dpadLayer, MELEE_RULESET_VERIFICATION_OUTPUT_DESTINATIONS));
}
